#!/usr/bin/env python3
"""Generates the per-site /[DOMAIN].json files served on map.snarfed.org.

Usage: make_site_files.py sites.json[.gz] social_graph_links.json[.gz]

where sites.json[.gz] is generated by sites_to_bigquery.py, and
social_graph_links.json[.gz] is this table:
https://bigquery.cloud.google.com/table/indie-map:indiemap.social_graph_links
created by the query 'Social graph: links by mf2, outbound':
https://bigquery.cloud.google.com/savedquery/464705913036:c1dce91deaed46a5bcf3452e5b781542

TODO:
- option to limit to input domains
- truncate at 1k (?), include total number
"""
from collections import defaultdict, OrderedDict
import decimal
from decimal import Decimal
import gzip
from itertools import chain
import operator
# simplejson supports encoding Decimal, but json doesn't
import simplejson as json
import sys

MF2_WEIGHTS = {
    'in-reply-to': 1,
    'invitee': 1,
    'quotation-of': .6,
    'repost-of': .6,
    'like-of': .4,
    'favorite-of': .4,
    'bookmark-of': .4,
    'other': .2,
}
DIRECTION_WEIGHTS = {
    'out': 1,
    'in': .5,
}

decimal.getcontext().prec = 3  # calculate/output scores at limited precision

# currently unused
with open('../crawl/domain_blacklist.txt', 'rt', encoding='utf-8') as f:
    BLACKLIST = frozenset((line.strip() for line in f if line.strip()))


def load_links(links_in):
    """Loads and processes a social graph links JSON file.

    Args:
      links_in: sequence of social graph links objects. See file docstring.

    Returns: (links, out_counts, in_counts)

    links:
      {'[DOMAIN]': {
          'links_out': [INTEGER],
          'links_in':  [INTEGER],
          'links': {
            'TO_DOMAIN': {
              'out': {
                'in-reply-to': [INTEGER],  # mf2 classes
                'like-of': [INTEGER],
                ...
                'other': [INTEGER],
              },
              'in': {
                [SAME]
              },
              'score': [FLOAT],
            },
            ...
          },
        },
        ...,
      }
    out_counts, in_counts: {'[DOMAIN]': [INTEGER]}
    """
    links = defaultdict(lambda: defaultdict(lambda: defaultdict(
        lambda: defaultdict(int))))
    out_counts = defaultdict(int)
    in_counts = defaultdict(int)

    for i, link in enumerate(links_in):
        if i and i % 10000 == 0:
            print('.', end='', flush=True)

        from_domain = link['from_domain']
        to_domain = link['to_domain']
        num = int(link['num'])
        mf2 = link.get('mf2_class', 'other')
        if mf2.startswith('u-'):
            mf2 = mf2[2:]

        links[from_domain][to_domain]['out'][mf2] += num
        links[to_domain][from_domain]['in'][mf2] += num
        out_counts[from_domain] += num
        in_counts[to_domain] += num

    return links, out_counts, in_counts


def make(sites, links, out_counts, in_counts):
    # calculate scores
    print('\nScoring', end='')
    for i, domains in enumerate(links.values()):
        if i and i % 10000 == 0:
            print('.', end='', flush=True)

        max_score = 0
        for stats in domains.values():
            score = 0
            for direction, counts in stats.items():
                for mf2, count in counts.items():
                    score += Decimal(count * MF2_WEIGHTS[mf2] *
                                     DIRECTION_WEIGHTS[direction])
            stats['score'] = score
            if score > max_score:
                max_score = score

        # normalize scores to (0, 1] per domain
        for stats in domains.values():
            stats['score'] /= max_score


    # emit each site
    print('\nOutputting', end='')
    for i, site in enumerate(sites):
        if i and i % 10 == 0:
            print('.', end='', flush=True)
        domain = site['domain']
        domain_links = links.get(domain, {})
        site.update({
            'hcard': json.loads(site.get('hcard', '{}')) or {},
            'links_out': out_counts.get(domain),
            'links_in': in_counts.get(domain),
            'links': OrderedDict(sorted(domain_links.items(),
                                        key=lambda item: item[1]['score'],
                                        reverse=True)),
        })
        site.pop('mf2', None)
        site.pop('html', None)
        yield site

    print()


def open_fn(path, mode):
    return (gzip.open if path.endswith('.gz') else open)(
        path, mode, encoding='utf-8')


def main(sites_file, links_file):
    print('Loading', end='')
    links, out_counts, in_counts = load_links(json.loads(l) for l in links_file)
    sites = [json.loads(line) for line in sites_file]
    return make(sites, links, out_counts, in_counts)


if __name__ == '__main__':
    with open_fn(sys.argv[1], 'rt') as sites_file, \
         open_fn(sys.argv[2], 'rt') as links_file:
        for site in main(sites_file, links_file):
            with open(site['domain'] + '.json', 'wt', encoding='utf-8') as out:
                json.dump(site, out, indent=2, ensure_ascii=False)
